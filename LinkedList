1，单链表
2，链表遍历，增删查改
3，双向链表
4，鱼数笔记操作系统数据结构

1，
#include<stdio.h>
typedef struct node{
  int data;
  struct node *pNext;
}node;
node *create_node(int data)
{
  node *p = (node *)malloc(sizeof(node));
  if(p == NULL){
    printf("malloc error!\n");
    return NULL;
  }
}
void insert_tail(node * ph,node * new)
{
  node *p = ph;
  while(NULL != p->pNext){
    p = p->pNext;
  };
  p->pNext = new;
}
int main()
{
  node * ph =create_tail(1);
  insert_tail(ph,create_tail(2));
  insert_tail(ph,create_tail(3));
  printf("node1 data:%d\n",ph->data);
  printf("dode2 data:%d\n",ph->pNext->data);
  printf("node3 data:%d\n",ph->pNext->pNext->data);
}
//无头节点
void list_for_each1(ndoe *ph)
{
  node * p =ph;
  while(NULL != p->pNext){
    printf("node data:%d\n",p->data);
    p=p->pNext;
  }
  printf("node data:%d\n",p->data);
}
//有头节点
void list_for_each2(node *ph)
{
  node * p = ph;
  while(NULL != p ){
    p = p -> pNext;
    printf("node data:%d\n",p->data);
  } 
}
//增删查改
void delete_node（node *pH, int data）
｛
  node *p = pH;
  node *pPrev = NULL;
  while(NULL != p->pNext){
    pPrev = p;
    p = p->pNext;
    if (p->data == data){
      if(NULL == p->pNext){
        pPrev->pNext = NULL;
        free(p);
      }
      else{
        pPrev->pNext = p->pNext;
        free(p);
      }
      return 0;
    }
  }
  printf("没有要删除的节点\n");
  return -1；
｝
//双向链表
typedef struct node{
  int data;
  struct node *pNext;
  struct node *pPrev;
}node;
node * create_node(int data)
{
  node * p = (node *)malloc(sizeof(node));
  if(NULL == p){
    printf("malloc error\n");
    return NULL;
  }
     p->data = data;
    p->pPrev = NULL;
    p->pNext = NULL;
    
    return p;
}
void insert_tail(node * pH, node * new)
{
    struct node *p = pH;
    while(NULL != p->pNext){
      p = p->pNext;
    }
    
    p->pNext = new;
    new->pPrev = p;
}
void insert_head(node * pH, node * new)
{
  new->pNext = pH->pNext;
  
  if(NULL != pH->pNext)
    pH->pNext->pPrev = new;
    
  pH->pNext = new;
  
  new->pPrev = pH;
}

